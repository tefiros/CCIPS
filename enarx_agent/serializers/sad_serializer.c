/********************************************************************

       IMPORTANT: AUTO-GENERATED FILE - DO NOT EDIT!                 

 Generated by: cser-1.0.0
 Command line: -o sad_serializer -b raw -i ../ipsec_interactor/base/sad_entry.h -v sad_entry_node 

********************************************************************/

#include "sad_serializer.h"
int cser_raw_store_struct_sad_entry_node (const struct sad_entry_node *val, cser_raw_write_fn w, void *q)
{
 {
   uint8_t present = (val->name != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->name) && ((i == 0) || (val->name[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->name[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
    {
      int ret = cser_raw_store_unsigned_long_long_int ((unsigned long long int*)&val->req_id, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->spi, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store__Bool ((_Bool*)&val->ext_seq_num, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store__Bool ((_Bool*)&val->seq_overflow, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_long_int ((unsigned long long int*)&val->seq_number_counter, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_long_int ((unsigned long long int*)&val->anti_replay_window, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
   uint8_t present = (val->local_subnet != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->local_subnet) && ((i == 0) || (val->local_subnet[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->local_subnet[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
   uint8_t present = (val->remote_subnet != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->remote_subnet) && ((i == 0) || (val->remote_subnet[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->remote_subnet[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
   uint8_t present = (val->tunnel_local != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->tunnel_local) && ((i == 0) || (val->tunnel_local[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->tunnel_local[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
   uint8_t present = (val->tunnel_remote != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->tunnel_remote) && ((i == 0) || (val->tunnel_remote[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->tunnel_remote[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
    {
      int ret = cser_raw_store_unsigned_int ((unsigned int*)&val->inner_protocol, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_int ((unsigned int*)&val->dstport, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_short ((unsigned short*)&val->ipsec_mode, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_short ((unsigned short*)&val->protocol_parameters, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_int ((unsigned int*)&val->integrity_alg, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_int ((unsigned int*)&val->encryption_alg, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
   uint8_t present = (val->encryption_key != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->encryption_key) && ((i == 0) || (val->encryption_key[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->encryption_key[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
   uint8_t present = (val->integrity_key != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->integrity_key) && ((i == 0) || (val->integrity_key[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->integrity_key[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
   uint8_t present = (val->encryption_iv != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
    for (size_t i = 0; (val->encryption_iv) && ((i == 0) || (val->encryption_iv[i-1])); ++i)
    {
      int ret = cser_raw_store_char ((char*)&val->encryption_iv[i], w, q);
      if (ret != 0)
        return ret;
   }
  }
 }
 {
    {
      int ret = cser_raw_store__Bool ((_Bool*)&val->bypass_dscp, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store__Bool ((_Bool*)&val->ecn, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store__Bool ((_Bool*)&val->tfc_pad, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_short ((unsigned short*)&val->df_bit, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_bytes_hard, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_bytes_soft, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_bytes_current, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_packets_hard, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_packets_soft, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_packets_current, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_time_hard, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_time_soft, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_time_current, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_idle_hard, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_idle_soft, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
    {
      int ret = cser_raw_store_unsigned_long_int ((unsigned long int*)&val->lft_idle_current, w, q);
      if (ret != 0)
        return ret;
   }

 }
 {
   uint8_t present = (val->next != 0);
   int ret = w (&present, sizeof (present), q);
   if (ret != 0)
     return ret;
   if (present)
   {
      int ret = cser_raw_store_struct_sad_entry_node ((struct sad_entry_node*)val->next, w, q);
      if (ret != 0)
        return ret;
   }

 }
  return 0;
}
int cser_raw_load_struct_sad_entry_node (struct sad_entry_node *val, cser_raw_read_fn r, void *q)
{
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->name = tmp;
  }
 }
 {
      int ret = cser_raw_load_unsigned_long_long_int ((unsigned long long int*)&val->req_id, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->spi, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load__Bool ((_Bool*)&val->ext_seq_num, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load__Bool ((_Bool*)&val->seq_overflow, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_long_int ((unsigned long long int*)&val->seq_number_counter, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_long_int ((unsigned long long int*)&val->anti_replay_window, r, q);
    if (ret != 0)
      return ret;
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->local_subnet = tmp;
  }
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->remote_subnet = tmp;
  }
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->tunnel_local = tmp;
  }
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->tunnel_remote = tmp;
  }
 }
 {
      int ret = cser_raw_load_unsigned_int ((unsigned int*)&val->inner_protocol, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_int ((unsigned int*)&val->dstport, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_short ((unsigned short*)&val->ipsec_mode, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_short ((unsigned short*)&val->protocol_parameters, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_int ((unsigned int*)&val->integrity_alg, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_int ((unsigned int*)&val->encryption_alg, r, q);
    if (ret != 0)
      return ret;
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->encryption_key = tmp;
  }
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->integrity_key = tmp;
  }
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
    char *tmp = 0;
    size_t n = 0;
    size_t offs = 0;
    do {
      if (offs >= n)
      {
        if (n == 0)
          n = 2 * sizeof(char);
        tmp = (char *)realloc (tmp, n *= 2);
        if (!tmp)
          return -ENOMEM;
        memset ((char *)tmp + n/2, n/2, 0);
      }
      int ret = cser_raw_load_char ((char*)&tmp[offs++], r, q);
      if (ret != 0)
      {
        free (tmp);
        return ret;
      }
    } while (tmp[offs - 1]);
    val->encryption_iv = tmp;
  }
 }
 {
      int ret = cser_raw_load__Bool ((_Bool*)&val->bypass_dscp, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load__Bool ((_Bool*)&val->ecn, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load__Bool ((_Bool*)&val->tfc_pad, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_short ((unsigned short*)&val->df_bit, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_bytes_hard, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_bytes_soft, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_bytes_current, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_packets_hard, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_packets_soft, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_packets_current, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_time_hard, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_time_soft, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_time_current, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_idle_hard, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_idle_soft, r, q);
    if (ret != 0)
      return ret;
 }
 {
      int ret = cser_raw_load_unsigned_long_int ((unsigned long int*)&val->lft_idle_current, r, q);
    if (ret != 0)
      return ret;
 }
 {
  uint8_t present;
  int ret = r (&present, sizeof (present), q);
  if (ret != 0)
    return ret;
  if (present)
  {
      struct sad_entry_node *tmp_item = calloc (1, sizeof (struct sad_entry_node));
      if (!tmp_item)
        return -ENOMEM;
      int ret = cser_raw_load_struct_sad_entry_node (tmp_item, r, q);
      if (ret == 0)
        val->next = tmp_item;
      else
        free (tmp_item);
    if (ret != 0)
      return ret;
  }
 }
  return 0;
}
int cser_raw_store_unsigned_long_long_int (const unsigned long long int *val, cser_raw_write_fn w, void *q)
{
  unsigned long long int tmp = *val;
  uint8_t bytes[sizeof (unsigned long long int)];
  for (unsigned i = 1; i <= sizeof (unsigned long long int); ++i)
  {
    bytes[sizeof (unsigned long long int) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (unsigned long long int), q);
}
int cser_raw_load_unsigned_long_long_int (unsigned long long int *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (unsigned long long int)];
  int ret = r (bytes, sizeof (unsigned long long int), q);
  if (ret != 0)
    return ret;
  unsigned long long int tmp = 0;
  for (unsigned i = 0; i < (sizeof (unsigned long long int)); ++i)
    tmp = (unsigned long long int)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
int cser_raw_store_unsigned_long_int (const unsigned long int *val, cser_raw_write_fn w, void *q)
{
  unsigned long int tmp = *val;
  uint8_t bytes[sizeof (unsigned long int)];
  for (unsigned i = 1; i <= sizeof (unsigned long int); ++i)
  {
    bytes[sizeof (unsigned long int) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (unsigned long int), q);
}
int cser_raw_load_unsigned_long_int (unsigned long int *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (unsigned long int)];
  int ret = r (bytes, sizeof (unsigned long int), q);
  if (ret != 0)
    return ret;
  unsigned long int tmp = 0;
  for (unsigned i = 0; i < (sizeof (unsigned long int)); ++i)
    tmp = (unsigned long int)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
int cser_raw_store_unsigned_int (const unsigned int *val, cser_raw_write_fn w, void *q)
{
  unsigned int tmp = *val;
  uint8_t bytes[sizeof (unsigned int)];
  for (unsigned i = 1; i <= sizeof (unsigned int); ++i)
  {
    bytes[sizeof (unsigned int) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (unsigned int), q);
}
int cser_raw_load_unsigned_int (unsigned int *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (unsigned int)];
  int ret = r (bytes, sizeof (unsigned int), q);
  if (ret != 0)
    return ret;
  unsigned int tmp = 0;
  for (unsigned i = 0; i < (sizeof (unsigned int)); ++i)
    tmp = (unsigned int)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
int cser_raw_store_unsigned_short (const unsigned short *val, cser_raw_write_fn w, void *q)
{
  unsigned short tmp = *val;
  uint8_t bytes[sizeof (unsigned short)];
  for (unsigned i = 1; i <= sizeof (unsigned short); ++i)
  {
    bytes[sizeof (unsigned short) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (unsigned short), q);
}
int cser_raw_load_unsigned_short (unsigned short *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (unsigned short)];
  int ret = r (bytes, sizeof (unsigned short), q);
  if (ret != 0)
    return ret;
  unsigned short tmp = 0;
  for (unsigned i = 0; i < (sizeof (unsigned short)); ++i)
    tmp = (unsigned short)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
int cser_raw_store_char (const char *val, cser_raw_write_fn w, void *q)
{
  char tmp = *val;
  uint8_t bytes[sizeof (char)];
  for (unsigned i = 1; i <= sizeof (char); ++i)
  {
    bytes[sizeof (char) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (char), q);
}
int cser_raw_load_char (char *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (char)];
  int ret = r (bytes, sizeof (char), q);
  if (ret != 0)
    return ret;
  char tmp = 0;
  for (unsigned i = 0; i < (sizeof (char)); ++i)
    tmp = (char)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
int cser_raw_store__Bool (const _Bool *val, cser_raw_write_fn w, void *q)
{
  _Bool tmp = *val;
  uint8_t bytes[sizeof (_Bool)];
  for (unsigned i = 1; i <= sizeof (_Bool); ++i)
  {
    bytes[sizeof (_Bool) - i] = (uint8_t)(tmp & 0xff);
    tmp >>= 8;
  }
  return w (bytes, sizeof (_Bool), q);
}
int cser_raw_load__Bool (_Bool *val, cser_raw_read_fn r, void *q)
{
  uint8_t bytes[sizeof (_Bool)];
  int ret = r (bytes, sizeof (_Bool), q);
  if (ret != 0)
    return ret;
  _Bool tmp = 0;
  for (unsigned i = 0; i < (sizeof (_Bool)); ++i)
    tmp = (_Bool)((tmp << 8) | bytes[i]);
  *val = tmp;
  return 0;
}
