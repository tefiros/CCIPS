/*
 * i2nsf-api
 *
 * API to deploy the i2nsf tunnel
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"encoding/json"
	"fmt"
	"net/http"
	"path"
	"sync"

	"github.com/google/uuid"
)

func ApiCreateI2nsf(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var cfgRequest I2NSFRequest
	err := json.NewDecoder(r.Body).Decode(&cfgRequest)

	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	response, err := storage.CreateHandler(&cfgRequest)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	} else {
		jData, err := json.Marshal(response)
		if err != nil {
			fmt.Println(err.Error())
		}
		w.Write(jData)
	}
	//w.WriteHeader(http.StatusOK)
}

func ApiDeleteI2nsf(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	rId, err := uuid.Parse(path.Base(r.URL.String()))
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if err := storage.DeleteHandler(rId); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func ApiStatusI2nsf(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	rId, err := uuid.Parse(path.Base(r.URL.String()))
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	response := storage.GetConfig(rId)
	//if err != nil {
	//	http.Error(w, err.Error(), http.StatusBadRequest)
	//	return
	//} else {
	jData, err := json.Marshal(response)
	if err != nil {
		fmt.Println(err.Error())
	}
	w.Write(jData)
	//}

	//w.WriteHeader(http.StatusOK)
}

// CertificateRequest represents the structure of the request body for uploading a certificate
type CertificateRequest struct {
	Certificate string `json:"certificate"`
}

// In-memory storage for certificates
var certStore = struct {
	sync.RWMutex
	certs map[uuid.UUID]string
}{
	certs: make(map[uuid.UUID]string),
}

// ApiUploadCertificate handles the uploading of an X.509 certificate
func ApiUploadCertificate(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var certRequest CertificateRequest
	err := json.NewDecoder(r.Body).Decode(&certRequest)

	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Generate a unique ID for the certificate
	certID := uuid.New()

	// Store the certificate in memory
	storeCertificate(certID, certRequest.Certificate)

	response := certID
	jData, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(jData)
}

// storeCertificate stores the certificate in the in-memory storage
func storeCertificate(certID uuid.UUID, cert string) {
	certStore.Lock()
	defer certStore.Unlock()
	certStore.certs[certID] = cert
}

// ApiGetCertificate handles retrieving a stored certificate
func ApiGetCertificate(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Get the certificate ID from the URL query parameters
	certID, err := uuid.Parse(path.Base(r.URL.String()))
	if err != nil {
		http.Error(w, "certID parameter is required", http.StatusBadRequest)
		return
	}

	// Retrieve the certificate from memory
	cert, err := getCertificate(certID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}

	response := map[string]string{"certificate": cert}
	jData, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(jData)
}

// getCertificate retrieves the certificate from the in-memory storage
func getCertificate(certID uuid.UUID) (string, error) {
	certStore.RLock()
	defer certStore.RUnlock()
	cert, exists := certStore.certs[certID]
	if !exists {
		return "", fmt.Errorf("certificate not found: %s", certID)
	}
	return cert, nil
}
